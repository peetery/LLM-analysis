{
  "model": "o3",
  "strategy": "chain_of_thought_prompting",
  "context_type": "interface",
  "timestamp": "2025-07-03T01:04:04.063403",
  "response_time": 110.581618309021,
  "test_file": "prompts_results\\chain_of_thought_prompting\\interface\\gpt-o3\\tests.py",
  "raw_results": {
    "responses": [
      {
        "step": 1,
        "prompt": "You are a software testing assistant. Your task is to generate a set of unit tests for a Python class provided below.\n\nThe tests should:\n- use the `unittest` framework,\n- cover all public methods,\n- test typical usage as well as edge cases, invalid inputs, and exceptions,\n- be clear, atomic, and minimal.\n\nYou will now analyze the class to prepare relevant test cases.\nDo not write test code yet. Do not write test scenarios yet. Just analyze the class and prepare for the next step.\n\nBelow is the class interface (without implementation):\n\n```python\nfrom typing import TypedDict, List\n\nclass Item(TypedDict)\n\nclass OrderCalculator:\n    def __init__(self, tax_rate=0.23, free_shipping_threshold=100.0, shipping_cost=10.0):\n\ndef add_item(self, name: str, price: float, quantity: int = 1):\n\ndef remove_item(self, name: str):\n\ndef get_subtotal(self) -> float:\n\ndef apply_discount(self, subtotal: float, discount: float) -> float:\n\ndef calculate_shipping(self, discounted_subtotal: float) -> float:\n\ndef calculate_tax(self, amount: float) -> float:\n\ndef calculate_total(self, discount: float = 0.0) -> float:\n\ndef total_items(self) -> int:\n\ndef clear_order(self):\n\ndef list_items(self) -> List[str]:\n\ndef is_empty(self) -> bool:\n\n```\n\n",
        "response": "Preliminary analysis of OrderCalculator\nBelow is a structured look-ahead at what the public interface implies, what should be verified, and the corner-cases that will matter once we craft the actual unit-tests. (Nothing here is the test code itself; it is simply the groundwork.)\nMethod Core contract likely intended Typical (“happy-path”) checks Edge / invalid-input checks\n__init__(tax_rate, free_shipping_threshold, shipping_cost) Stores parameters and starts with an empty order • Default values are respected.\n• Custom values are stored and later used in calculations. • Non-numeric or negative tax/shipping/threshold should raise (or at least coerce) — we’ll probe for ValueError/TypeError.\nadd_item(name, price, quantity=1) Adds or increments an item line • Single add, then verify subtotal & item list.\n• Adding same name twice accumulates quantity (if that’s the design). • Negative/zero price or qty.\n• Non-string names.\n• Very large qty (stress).\nremove_item(name) Deletes an item line • Remove after adding and ensure subtotals & counts update. • Removing an absent item → expect KeyError (or custom).\nget_subtotal() Σ(price × qty) • After various adds/removes. • Empty order → 0.0.\napply_discount(subtotal, discount) Calculates discounted subtotal • Discount 0 and positive.\n• Discount equals subtotal. • Discount > subtotal.\n• Negative discount.\n• Float precision (assertAlmostEqual).\ncalculate_shipping(discounted_subtotal) Returns either 0 or shipping_cost • Subtotal above, below, exactly at the free threshold. • Negative subtotal.\ncalculate_tax(amount) amount × tax_rate • Standard positive amount calculation. • Zero amount.\n• Negative amount (should raise or zero).\ncalculate_total(discount=0.0) End-to-end pipeline: subtotal → discount → shipping → tax • Normal flow with multiple items & discount.\n• Verify combined math with custom constructor values. • Empty cart returns 0.\n• Discount triggers free shipping boundary.\n• Invalid discount propagates error.\ntotal_items() Σ(quantities) • After mixed adds/removes. • Empty order returns 0.\nclear_order() Empties everything • After clear: is_empty == True, subtotal == 0, etc.\nlist_items() Returns list of item names • Order of names (may be insertion order).\n• After clear it’s empty. • Ensure duplicates appear once or per add behavior.\nis_empty() True iff no items • Fresh instance & after clear (True).\n• After add (False). —\nCross-cutting considerations\nFloating-point rounding:\nTotals and taxes will be compared with assertAlmostEqual to avoid brittle tests.\nState isolation:\nEvery test method will create its own fresh OrderCalculator instance to keep tests atomic.\nException semantics:\nWhere the behaviour is ambiguous (e.g., how negative discounts are handled), tests will first expect a specific exception; if implementation differs we’ll adapt.\nParameterisation coverage:\nAt least one test will instantiate the class with non-default tax_rate, free_shipping_threshold, and shipping_cost to ensure those parameters are honoured globally.\nBoundary values:\n• Free-shipping threshold (just below, exactly equal, just above).\n• Discount equal to subtotal.\n• Quantities of 1 vs. large numbers.\nBehavioural chaining:\nSome tests will call public helpers (get_subtotal, apply_discount, etc.) directly and implicitly through calculate_total to ensure internal orchestration is correct.\nThese insights will guide the concrete test scenarios (next step) and guarantee that every public surface and critical edge case is exercised.",
        "response_time": 38.83222198486328
      },
      {
        "step": 2,
        "prompt": "Based on the class above, list all relevant unit test scenarios you would create.\nEach scenario should describe:\n- the method being tested,\n- the type of case (e.g. normal use, invalid input, exception),\n- a short explanation of the intent.\nList as many scenarios as you can think of, covering all aspects of the class.\nDo not write test code yet.\n\n",
        "response": "Below is an exhaustive catalogue of unit-test scenarios that together probe every public method of OrderCalculator, including nominal behaviour, boundary conditions, error handling, and state interactions.\n# Method under test Case type Intent / what the test proves\nConstructor\n1 __init__ Normal use Default parameters (tax_rate = 0.23, free_shipping_threshold = 100.0, shipping_cost = 10.0) are stored and retrievable through later calculations.\n2 __init__ Normal use Custom non-default parameters propagate into subsequent calculate_tax, calculate_shipping, and calculate_total calls.\n3 __init__ Invalid input Negative tax_rate raises ValueError (or equivalent defensive error).\n4 __init__ Invalid input Negative free_shipping_threshold raises error.\n5 __init__ Invalid input Negative shipping_cost raises error.\nItem addition / removal\n6 add_item Normal use Adding a single item with default quantity updates subtotal and total_items correctly.\n7 add_item Normal use Adding an item with an explicit quantity > 1 multiplies line price accordingly.\n8 add_item Normal use Adding a second time under the same name accumulates quantity rather than duplicating the entry.\n9 add_item Edge Very large quantity (e.g. 10 000) handled without overflow; subtotal accurate.\n10 add_item Invalid input Negative price triggers ValueError.\n11 add_item Invalid input Zero or negative quantity triggers ValueError.\n12 add_item Invalid input Non-string name raises TypeError.\n13 remove_item Normal use Removing an existing item reduces subtotal and item count as expected.\n14 remove_item Exception Removing an item not in the order raises KeyError (or defined error).\nOrder state helpers\n15 is_empty Normal use Fresh instance returns True.\n16 is_empty Normal use After at least one add_item, returns False.\n17 total_items Normal use Empty order returns 0.\n18 total_items Normal use Sum of quantities across multiple lines is returned.\n19 list_items Normal use Returns list of names in insertion order after several additions.\n20 list_items Normal use After clear_order it returns an empty list.\n21 clear_order Normal use Clears items, sets subtotal = 0, and flips is_empty to True.\nMonetary helpers\n22 get_subtotal Normal use Correct subtotal after multiple varied items.\n23 get_subtotal Edge Returns 0.0 for an empty order.\n24 apply_discount Normal use Discount 0.0 returns unchanged subtotal.\n25 apply_discount Normal use Discount less than subtotal is subtracted exactly (use assertAlmostEqual).\n26 apply_discount Boundary Discount equal to subtotal returns 0.0.\n27 apply_discount Invalid input Discount larger than subtotal raises ValueError.\n28 apply_discount Invalid input Negative discount raises ValueError.\n29 calculate_shipping Normal use Subtotal strictly below threshold incurs shipping_cost.\n30 calculate_shipping Boundary Subtotal exactly equal to threshold yields free shipping (0 cost).\n31 calculate_shipping Normal use Subtotal above threshold yields free shipping (0 cost).\n32 calculate_shipping Invalid input Negative subtotal raises ValueError.\n33 calculate_tax Normal use Tax on positive amount = amount × tax_rate.\n34 calculate_tax Edge Zero amount results in 0.0 tax.\n35 calculate_tax Invalid input Negative amount raises ValueError.\nEnd-to-end total\n36 calculate_total Normal use Typical order with multiple items and no discount returns subtotal + shipping + tax.\n37 calculate_total Normal use Same order with discount (< threshold) still charges shipping.\n38 calculate_total Boundary Discount large enough to move discounted subtotal above free-shipping threshold removes shipping cost.\n39 calculate_total Boundary Discount exactly equal to subtotal produces total = tax on 0 + 0 shipping = 0.\n40 calculate_total Edge Empty cart returns total 0.0 regardless of discount value.\n41 calculate_total Invalid input Negative discount raises ValueError.\n42 calculate_total Normal use Instance created with custom tax rate, threshold, and shipping cost still computes correctly.\n43 calculate_total Precision Uses assertAlmostEqual to confirm floating-point rounding for a case producing long decimals (e.g. 0.1 × 3).\nState-transition interactions\n44 Mixed methods Normal use Chain: add items → remove one → add another → clear → verify that subsequent calls (get_subtotal, list_items, calculate_total) all reflect cleared state.\n45 Mixed methods Concurrency edge Two separate OrderCalculator instances operate independently (actions on one do not affect the other).\nThese 45 scenarios collectively exercise every public behaviour, boundary, and error path exposed by the OrderCalculator interface, laying a solid foundation for the forthcoming implementation of actual unittest cases.",
        "response_time": 30.180496215820312
      },
      {
        "step": 3,
        "prompt": "Now, based on the test scenarios you just listed, generate the complete Python unit test suite using the `unittest` framework.\n\nFollow these rules:\n- Include one test method per scenario.\n- Use meaningful test method names.\n- Do not include comments or explanations.\n- Output a valid `.py` file containing only the test class.\n\nThe output must contain only Python code.",
        "response": "python\nKopiuj\nEdytuj\nimport unittest\nfrom order_calculator import OrderCalculator\n\n\nclass TestOrderCalculator(unittest.TestCase):\n\n    # Constructor\n    def test_init_defaults(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.calculate_tax(100), 23)\n\n    def test_init_custom_parameters(self):\n        oc = OrderCalculator(tax_rate=0.1, free_shipping_threshold=50, shipping_cost=5)\n        self.assertAlmostEqual(oc.calculate_tax(100), 10)\n        oc.add_item(\"item\", 40)\n        self.assertEqual(oc.calculate_shipping(40), 5)\n\n    def test_init_negative_tax_rate_raises(self):\n        with self.assertRaises(ValueError):\n            OrderCalculator(tax_rate=-0.1)\n\n    def test_init_negative_free_shipping_threshold_raises(self):\n        with self.assertRaises(ValueError):\n            OrderCalculator(free_shipping_threshold=-1)\n\n    def test_init_negative_shipping_cost_raises(self):\n        with self.assertRaises(ValueError):\n            OrderCalculator(shipping_cost=-5)\n\n    # add_item / remove_item\n    def test_add_item_single(self):\n        oc = OrderCalculator()\n        oc.add_item(\"apple\", 2.0)\n        self.assertAlmostEqual(oc.get_subtotal(), 2.0)\n\n    def test_add_item_quantity(self):\n        oc = OrderCalculator()\n        oc.add_item(\"banana\", 1.5, 3)\n        self.assertAlmostEqual(oc.get_subtotal(), 4.5)\n\n    def test_add_item_accumulates_quantity(self):\n        oc = OrderCalculator()\n        oc.add_item(\"cookie\", 1.0)\n        oc.add_item(\"cookie\", 1.0, 2)\n        self.assertEqual(oc.total_items(), 3)\n\n    def test_add_item_large_quantity(self):\n        oc = OrderCalculator()\n        oc.add_item(\"bulk\", 0.1, 10000)\n        self.assertAlmostEqual(oc.get_subtotal(), 1000)\n\n    def test_add_item_negative_price_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.add_item(\"bad\", -1.0)\n\n    def test_add_item_negative_quantity_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.add_item(\"bad\", 1.0, -2)\n\n    def test_add_item_non_string_name_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(TypeError):\n            oc.add_item(123, 1.0)\n\n    def test_remove_item(self):\n        oc = OrderCalculator()\n        oc.add_item(\"milk\", 3.0)\n        oc.remove_item(\"milk\")\n        self.assertTrue(oc.is_empty())\n\n    def test_remove_nonexistent_item_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(KeyError):\n            oc.remove_item(\"ghost\")\n\n    # Order state helpers\n    def test_is_empty_fresh(self):\n        self.assertTrue(OrderCalculator().is_empty())\n\n    def test_is_empty_after_add(self):\n        oc = OrderCalculator()\n        oc.add_item(\"egg\", 0.2)\n        self.assertFalse(oc.is_empty())\n\n    def test_total_items_empty(self):\n        self.assertEqual(OrderCalculator().total_items(), 0)\n\n    def test_total_items_multiple_lines(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 1.0, 2)\n        oc.add_item(\"b\", 1.0, 3)\n        self.assertEqual(oc.total_items(), 5)\n\n    def test_list_items_order(self):\n        oc = OrderCalculator()\n        oc.add_item(\"x\", 1.0)\n        oc.add_item(\"y\", 1.0)\n        self.assertEqual(oc.list_items(), [\"x\", \"y\"])\n\n    def test_list_items_empty_after_clear(self):\n        oc = OrderCalculator()\n        oc.add_item(\"z\", 1.0)\n        oc.clear_order()\n        self.assertEqual(oc.list_items(), [])\n\n    def test_clear_order(self):\n        oc = OrderCalculator()\n        oc.add_item(\"w\", 1.0)\n        oc.clear_order()\n        self.assertTrue(oc.is_empty())\n        self.assertAlmostEqual(oc.get_subtotal(), 0.0)\n\n    # Monetary helpers\n    def test_get_subtotal_multiple_items(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 1.0, 2)\n        oc.add_item(\"b\", 1.5)\n        self.assertAlmostEqual(oc.get_subtotal(), 3.5)\n\n    def test_get_subtotal_empty(self):\n        self.assertAlmostEqual(OrderCalculator().get_subtotal(), 0.0)\n\n    def test_apply_discount_zero(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.apply_discount(100, 0), 100)\n\n    def test_apply_discount_positive(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.apply_discount(100, 20), 80)\n\n    def test_apply_discount_equal_subtotal(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.apply_discount(50, 50), 0.0)\n\n    def test_apply_discount_greater_than_subtotal_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.apply_discount(50, 60)\n\n    def test_apply_discount_negative_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.apply_discount(50, -5)\n\n    def test_calculate_shipping_below_threshold(self):\n        oc = OrderCalculator()\n        self.assertEqual(oc.calculate_shipping(99.99), 10.0)\n\n    def test_calculate_shipping_exact_threshold(self):\n        oc = OrderCalculator()\n        self.assertEqual(oc.calculate_shipping(100.0), 0.0)\n\n    def test_calculate_shipping_above_threshold(self):\n        oc = OrderCalculator()\n        self.assertEqual(oc.calculate_shipping(150.0), 0.0)\n\n    def test_calculate_shipping_negative_subtotal_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.calculate_shipping(-1)\n\n    def test_calculate_tax_positive_amount(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.calculate_tax(50), 11.5)\n\n    def test_calculate_tax_zero_amount(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.calculate_tax(0), 0)\n\n    def test_calculate_tax_negative_amount_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.calculate_tax(-10)\n\n    # calculate_total\n    def test_calculate_total_no_discount(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 40)\n        self.assertAlmostEqual(oc.calculate_total(), 40 + 10 + (40 * 0.23))\n\n    def test_calculate_total_with_discount_below_threshold(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 40)\n        total = oc.calculate_total(discount=10)\n        self.assertAlmostEqual(total, 30 + 10 + (30 * 0.23))\n\n    def test_calculate_total_discount_triggers_free_shipping(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 110)\n        total = oc.calculate_total(discount=15)\n        discounted = 95\n        expected = discounted + 0 + (discounted * 0.23)\n        self.assertAlmostEqual(total, expected)\n\n    def test_calculate_total_discount_equal_subtotal(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 50)\n        self.assertAlmostEqual(oc.calculate_total(discount=50), 0)\n\n    def test_calculate_total_empty_cart(self):\n        self.assertAlmostEqual(OrderCalculator().calculate_total(), 0)\n\n    def test_calculate_total_negative_discount_raises(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 10)\n        with self.assertRaises(ValueError):\n            oc.calculate_total(discount=-1)\n\n    def test_calculate_total_custom_parameters(self):\n        oc = OrderCalculator(tax_rate=0.1, free_shipping_threshold=30, shipping_cost=5)\n        oc.add_item(\"a\", 20)\n        self.assertAlmostEqual(oc.calculate_total(), 20 + 5 + 2)\n\n    def test_calculate_total_precision(self):\n        oc = OrderCalculator()\n        oc.add_item(\"small\", 0.1, 3)\n        expected = 0.3 + 10 + (0.3 * 0.23)\n        self.assertAlmostEqual(oc.calculate_total(), expected)\n\n    # State-transition interactions\n    def test_chain_add_remove_clear(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 10)\n        oc.add_item(\"b\", 20)\n        oc.remove_item(\"a\")\n        oc.add_item(\"c\", 5)\n        oc.clear_order()\n        self.assertTrue(oc.is_empty())\n        self.assertAlmostEqual(oc.calculate_total(), 0)\n\n    def test_two_instances_independent(self):\n        oc1 = OrderCalculator()\n        oc2 = OrderCalculator()\n        oc1.add_item(\"a\", 10)\n        self.assertAlmostEqual(oc1.get_subtotal(), 10)\n        self.assertAlmostEqual(oc2.get_subtotal(), 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
        "response_time": 41.5689001083374
      }
    ],
    "final_response": "python\nKopiuj\nEdytuj\nimport unittest\nfrom order_calculator import OrderCalculator\n\n\nclass TestOrderCalculator(unittest.TestCase):\n\n    # Constructor\n    def test_init_defaults(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.calculate_tax(100), 23)\n\n    def test_init_custom_parameters(self):\n        oc = OrderCalculator(tax_rate=0.1, free_shipping_threshold=50, shipping_cost=5)\n        self.assertAlmostEqual(oc.calculate_tax(100), 10)\n        oc.add_item(\"item\", 40)\n        self.assertEqual(oc.calculate_shipping(40), 5)\n\n    def test_init_negative_tax_rate_raises(self):\n        with self.assertRaises(ValueError):\n            OrderCalculator(tax_rate=-0.1)\n\n    def test_init_negative_free_shipping_threshold_raises(self):\n        with self.assertRaises(ValueError):\n            OrderCalculator(free_shipping_threshold=-1)\n\n    def test_init_negative_shipping_cost_raises(self):\n        with self.assertRaises(ValueError):\n            OrderCalculator(shipping_cost=-5)\n\n    # add_item / remove_item\n    def test_add_item_single(self):\n        oc = OrderCalculator()\n        oc.add_item(\"apple\", 2.0)\n        self.assertAlmostEqual(oc.get_subtotal(), 2.0)\n\n    def test_add_item_quantity(self):\n        oc = OrderCalculator()\n        oc.add_item(\"banana\", 1.5, 3)\n        self.assertAlmostEqual(oc.get_subtotal(), 4.5)\n\n    def test_add_item_accumulates_quantity(self):\n        oc = OrderCalculator()\n        oc.add_item(\"cookie\", 1.0)\n        oc.add_item(\"cookie\", 1.0, 2)\n        self.assertEqual(oc.total_items(), 3)\n\n    def test_add_item_large_quantity(self):\n        oc = OrderCalculator()\n        oc.add_item(\"bulk\", 0.1, 10000)\n        self.assertAlmostEqual(oc.get_subtotal(), 1000)\n\n    def test_add_item_negative_price_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.add_item(\"bad\", -1.0)\n\n    def test_add_item_negative_quantity_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.add_item(\"bad\", 1.0, -2)\n\n    def test_add_item_non_string_name_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(TypeError):\n            oc.add_item(123, 1.0)\n\n    def test_remove_item(self):\n        oc = OrderCalculator()\n        oc.add_item(\"milk\", 3.0)\n        oc.remove_item(\"milk\")\n        self.assertTrue(oc.is_empty())\n\n    def test_remove_nonexistent_item_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(KeyError):\n            oc.remove_item(\"ghost\")\n\n    # Order state helpers\n    def test_is_empty_fresh(self):\n        self.assertTrue(OrderCalculator().is_empty())\n\n    def test_is_empty_after_add(self):\n        oc = OrderCalculator()\n        oc.add_item(\"egg\", 0.2)\n        self.assertFalse(oc.is_empty())\n\n    def test_total_items_empty(self):\n        self.assertEqual(OrderCalculator().total_items(), 0)\n\n    def test_total_items_multiple_lines(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 1.0, 2)\n        oc.add_item(\"b\", 1.0, 3)\n        self.assertEqual(oc.total_items(), 5)\n\n    def test_list_items_order(self):\n        oc = OrderCalculator()\n        oc.add_item(\"x\", 1.0)\n        oc.add_item(\"y\", 1.0)\n        self.assertEqual(oc.list_items(), [\"x\", \"y\"])\n\n    def test_list_items_empty_after_clear(self):\n        oc = OrderCalculator()\n        oc.add_item(\"z\", 1.0)\n        oc.clear_order()\n        self.assertEqual(oc.list_items(), [])\n\n    def test_clear_order(self):\n        oc = OrderCalculator()\n        oc.add_item(\"w\", 1.0)\n        oc.clear_order()\n        self.assertTrue(oc.is_empty())\n        self.assertAlmostEqual(oc.get_subtotal(), 0.0)\n\n    # Monetary helpers\n    def test_get_subtotal_multiple_items(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 1.0, 2)\n        oc.add_item(\"b\", 1.5)\n        self.assertAlmostEqual(oc.get_subtotal(), 3.5)\n\n    def test_get_subtotal_empty(self):\n        self.assertAlmostEqual(OrderCalculator().get_subtotal(), 0.0)\n\n    def test_apply_discount_zero(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.apply_discount(100, 0), 100)\n\n    def test_apply_discount_positive(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.apply_discount(100, 20), 80)\n\n    def test_apply_discount_equal_subtotal(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.apply_discount(50, 50), 0.0)\n\n    def test_apply_discount_greater_than_subtotal_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.apply_discount(50, 60)\n\n    def test_apply_discount_negative_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.apply_discount(50, -5)\n\n    def test_calculate_shipping_below_threshold(self):\n        oc = OrderCalculator()\n        self.assertEqual(oc.calculate_shipping(99.99), 10.0)\n\n    def test_calculate_shipping_exact_threshold(self):\n        oc = OrderCalculator()\n        self.assertEqual(oc.calculate_shipping(100.0), 0.0)\n\n    def test_calculate_shipping_above_threshold(self):\n        oc = OrderCalculator()\n        self.assertEqual(oc.calculate_shipping(150.0), 0.0)\n\n    def test_calculate_shipping_negative_subtotal_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.calculate_shipping(-1)\n\n    def test_calculate_tax_positive_amount(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.calculate_tax(50), 11.5)\n\n    def test_calculate_tax_zero_amount(self):\n        oc = OrderCalculator()\n        self.assertAlmostEqual(oc.calculate_tax(0), 0)\n\n    def test_calculate_tax_negative_amount_raises(self):\n        oc = OrderCalculator()\n        with self.assertRaises(ValueError):\n            oc.calculate_tax(-10)\n\n    # calculate_total\n    def test_calculate_total_no_discount(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 40)\n        self.assertAlmostEqual(oc.calculate_total(), 40 + 10 + (40 * 0.23))\n\n    def test_calculate_total_with_discount_below_threshold(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 40)\n        total = oc.calculate_total(discount=10)\n        self.assertAlmostEqual(total, 30 + 10 + (30 * 0.23))\n\n    def test_calculate_total_discount_triggers_free_shipping(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 110)\n        total = oc.calculate_total(discount=15)\n        discounted = 95\n        expected = discounted + 0 + (discounted * 0.23)\n        self.assertAlmostEqual(total, expected)\n\n    def test_calculate_total_discount_equal_subtotal(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 50)\n        self.assertAlmostEqual(oc.calculate_total(discount=50), 0)\n\n    def test_calculate_total_empty_cart(self):\n        self.assertAlmostEqual(OrderCalculator().calculate_total(), 0)\n\n    def test_calculate_total_negative_discount_raises(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 10)\n        with self.assertRaises(ValueError):\n            oc.calculate_total(discount=-1)\n\n    def test_calculate_total_custom_parameters(self):\n        oc = OrderCalculator(tax_rate=0.1, free_shipping_threshold=30, shipping_cost=5)\n        oc.add_item(\"a\", 20)\n        self.assertAlmostEqual(oc.calculate_total(), 20 + 5 + 2)\n\n    def test_calculate_total_precision(self):\n        oc = OrderCalculator()\n        oc.add_item(\"small\", 0.1, 3)\n        expected = 0.3 + 10 + (0.3 * 0.23)\n        self.assertAlmostEqual(oc.calculate_total(), expected)\n\n    # State-transition interactions\n    def test_chain_add_remove_clear(self):\n        oc = OrderCalculator()\n        oc.add_item(\"a\", 10)\n        oc.add_item(\"b\", 20)\n        oc.remove_item(\"a\")\n        oc.add_item(\"c\", 5)\n        oc.clear_order()\n        self.assertTrue(oc.is_empty())\n        self.assertAlmostEqual(oc.calculate_total(), 0)\n\n    def test_two_instances_independent(self):\n        oc1 = OrderCalculator()\n        oc2 = OrderCalculator()\n        oc1.add_item(\"a\", 10)\n        self.assertAlmostEqual(oc1.get_subtotal(), 10)\n        self.assertAlmostEqual(oc2.get_subtotal(), 0)\n\n\nif __name__ == \"__main__\":\n    unittest.main()",
    "total_response_time": 110.581618309021,
    "strategy": "chain_of_thought_prompting",
    "context_type": "interface"
  }
}